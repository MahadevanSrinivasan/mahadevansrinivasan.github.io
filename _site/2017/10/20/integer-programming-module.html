<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Optimized Integer Programming</title>
  <meta name="description" content="For one of my side projects, I had to solve an Integer Programming problem. I was initially contemplating on using some existing MATLAB/Octave package to the...">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/2017/10/20/integer-programming-module.html">
  <link rel="alternate" type="application/rss+xml" title="The Shy Bulb" href="http://localhost:4000/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">The Shy Bulb</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/projects/">Projects</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Optimized Integer Programming</h1>
    <p class="post-meta">Oct 20, 2017</p>
  </header>

  <article class="post-content">
    <p>For one of my side projects, I had to solve an <a href="https://en.wikipedia.org/wiki/Integer_programming">Integer Programming</a> problem. I was initially contemplating on using some existing MATLAB/Octave package to the job. The first  option that was available was the <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">Genetic Algorithm</a> module in MATLAB. It turned out to be too random and not methodical at all. This is not surprising as genetic algorithm is in essence a random algorithm and does not suit all kinds of problems. It could work for <a href="">some problems</a>. Next option was <a href="https://en.wikipedia.org/wiki/Simulated_annealing">Simulated Annealing</a>. Even for this, there was a package in MATLAB. It worked ok but the convergence was too slow for my needs. So, I ended up writing my own custom gradient descent algorithm to solve this problem using Python. In this article, I am going the detail the algorithm and the design choices.</p>

<h3 id="intro-to-integer-programming">Intro to Integer Programming</h3>

<p>Conventional definition of <em>Integer Programming</em> might be slightly different than my definition. But, here is the problem I was trying to solve. I had a system which had several parameters that needed hand-tuning and each of those parameters could only take <em>integer</em> values. This means, conventional gradient descent algorithms would not work as they are designed for real-valued parameter space. Why not do an exhaustive search over all possible parameters, you ask? You could if the parameter space is small. Now, imagine you have 15 different parameters each taking 15 different values. That is 15<sup>15</sup> parameters. If that does not look large, load up your calculator and check - this is equal to ~ 420 Quadrillion (Million Billion). Even if evaluating a single parameter set takes 1 micro-second, it is going to take 420 billion seconds to do the exhaustive search. So, that will take around 13354 years to complete. You get the drift.</p>

<h3 id="defining-the-parameter-space">Defining the parameter space</h3>

<p>First thing to do is define the parameter space. This means defining the lower and upper bounds (both inclusive) for your dataset. Here is an example on how to do it with a <code class="highlighter-rouge">numpy</code> array for a 8 parameter space.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">start_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></code></pre></figure>

<p>Notice, how the last parameter has the same upper and lower bound.  This means, we have fixed that parameter space for now. We can change it later if needed. Another key point here is the <code class="highlighter-rouge">dtype = np.int32</code>. This tells numpy that this array can only contain integer values. We are not planning to change this lower and upper bound arrays. This is just to tell whoever is reading the program that we are going to use integers. Now that we have defined the bounds, we can also define some <em>known</em> start points. May be you have optimized a similar problem before and want to use that knowledge for quicker convergence. I am going to define start points as a 2D array as we could have more than one. Here I have only one start point. But feel free to add more if you like.</p>

<h3 id="defining-the-fitness-function">Defining the fitness function</h3>

<p>Some people call this the cost function. Whatever name you choose, this is an absolute must for any optimization problem. This function should take as input a parameter set and should be able to evaluate the <code class="highlighter-rouge">fitness</code> of that set. Keep in mind, your optimization problem could try to minimize or maximize the fitness function and you need to define the return value of the fitness function accordingly. For simplicity, let us stick to minimizing the cost. Here is a prototype of a fitness function.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">fitness_function</span><span class="p">(</span><span class="n">curr_point</span><span class="p">):</span>
  <span class="s">""" Evaluate the fitness function """</span>
  <span class="k">return</span> <span class="n">cost</span></code></pre></figure>

<p>May be you cannot evaluate your fitness function using Python alone. If you have an executable, then you can just make it return the fitness value to your Python program. In any case, write a function that can provide a single number that you want to minimize.</p>

<h3 id="early-stopping">Early stopping</h3>

<p>Since we are searching a huge parameter space, we should add ways to stop early. I used the following two early-stopping criteria:</p>

<ul>
  <li>Fixed number of iterations</li>
  <li>Stop limit</li>
</ul>

<p>If you know how long you want the optimization routine to run, you can choose the number of iterations based on that. If each iteration takes 0.2 seconds and say you do not want to spend more than an hour, you could choose 18000 iterations.</p>

<p>Stop limit is a better early stopping method. May be you do not want the least cost function. As long as the cost function is below a certain limit, you are fine. In that case, if the fitness function goes below the stop limit, you can just stop searching then.</p>

<p>There are other popular techniques as well like: stop if the fitness function has not reduced in X iterations or stop if the fitness function has not reduced by more than some small number epsilon (say 0.001).</p>

<h3 id="gradient-descent-for-integer-programming">Gradient Descent for Integer Programming</h3>

<p>This is the key part of the problem. How do you move from one parameter set to a better parameter set? Let us look to the real-number gradient descent for inspiration. In that case, we calculate the differentiate the cost function with respect to each parameter separately and change the parameter by a small portion of the negative of those gradients. If this sounds too complicated, take a look at this <a href="https://www.coursera.org/learn/machine-learning/lecture/8SpIM/gradient-descent">Coursera video</a>. Main idea behind gradient descent is to change the parameter in the right direction but only by a small amount. Too large a change can cause the algorithm to diverge. Smaller changes are better even though they could take more time to converge. In Gradient Descent problems, this is called the learning rate. I will do another post on regular gradient descent soon.</p>

<p>For Integer Programming, we extend this idea but with a small twist. Take the current parameter set and compute its <strong>neighbors</strong> by making small changes to the current parameter set. Here is how I did it. A neighbor is a parameter set with just a single parameter incremented or decremented by 1 from the current point while still satisfying the bounds. An example might make it clear. For our initial starting point of <code class="highlighter-rouge">[7, 7, 7, 7, 7, 7, 5, 10]</code>, a valid neighbor is <code class="highlighter-rouge">[8, 7, 7, 7, 7, 7, 5, 10]</code>. An invalid neighbor is <code class="highlighter-rouge">[7, 7, 7, 7, 7, 7, 5, 11]</code> since the last parameter is not within the bounds. Once we calculate all the valid neighbors, next step is to evaluate the cost for all these neighbors and also the current parameter set. Armed with these costs, we can now make a decision of which parameter set to move to from the current parameter set. It is the one that decreases the cost function the most. And this neighbor becomes the current parameter set and we repeat this process till we cannot reduce the cost further (which will happen sooner or later). <code class="highlighter-rouge">find_neighbors</code> function is left as an exercise to the reader. I will provide an implementation in the complete code.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">find_neighbors</span><span class="p">(</span><span class="n">curr_point</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">):</span>
  <span class="s">""" Find all the valid neighbors """</span>
  <span class="k">return</span> <span class="n">neighbors</span></code></pre></figure>

<h3 id="peek-into-a-gradient-descent-iteration">Peek into a Gradient Descent Iteration</h3>

<p>Before we dive into the gradient descent iteration, let us discuss how to make sure we don’t evaluate the same parameter set mutliple times. This turns out to be quite simple. We just need to store the evaluated parameter sets/costs in a hash table. In python, we can use a dictionary to do this. Here is the code that runs one iteration of gradient descent starting from a parameter set <code class="highlighter-rouge">curr_point</code>. Notice how I convert the array to a string to be used as the key to the hash table as you cannot use a list as a key. One last function that we have not talked about is the <code class="highlighter-rouge">mark_neighbors_as_complete</code> function. The purpose of this function is to not visit the <em>sub-optimal</em> neigbors again. That function will iterate over all the parameter sets except the <code class="highlighter-rouge">curr_point</code> and set their costs to infinity in the hash table. I will provide an implementation in the complete code.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">gradient_descent_iteration</span><span class="p">(</span><span class="n">curr_point</span><span class="p">):</span>
  <span class="n">param_cost_map</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">best_iter_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
  <span class="n">best_iter_point</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="n">neighbors</span> <span class="o">=</span> <span class="n">curr_point</span>
  <span class="n">iter_num</span> <span class="o">=</span> <span class="mi">0</span>
  
  <span class="k">while</span> <span class="n">neighbors</span><span class="o">.</span><span class="nb">any</span><span class="p">():</span>
    <span class="n">curr_point</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">curr_point</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param_cost_map</span><span class="p">:</span>
      <span class="n">curr_score</span> <span class="o">=</span> <span class="n">param_cost_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">curr_score</span> <span class="o">=</span> <span class="n">fitness_function</span><span class="p">(</span><span class="n">curr_point</span><span class="p">)</span>
      <span class="n">param_cost_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_score</span>
    
    <span class="k">if</span> <span class="n">curr_score</span> <span class="o">&gt;</span> <span class="n">best_iter_score</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">curr_score</span> <span class="o">-</span> <span class="n">best_iter_score</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">:</span>
      <span class="n">mark_neighbors_as_complete</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
      <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">best_iter_score</span> <span class="o">=</span> <span class="n">curr_score</span>
      <span class="n">best_iter_point</span> <span class="o">=</span> <span class="n">curr_point</span>
      <span class="n">neighbors</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">best_iter_point</span><span class="p">)</span>
      
  <span class="k">return</span> <span class="n">best_iter_score</span><span class="p">,</span> <span class="n">best_iter_point</span></code></pre></figure>

<h3 id="restarting-searches">Restarting searches</h3>

<p>A single iteration might end very quickly depending on how good the starting point is. What happens when we are in a rut where the cost function stops decreasing? We need to restart the search from a random point and repeat the iteration again. Here is a simple implementation of a random point generation. Quite self-explanatory.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">generate_random_point</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">):</span>
  <span class="n">new_start_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_bound</span><span class="p">)):</span>
    <span class="n">new_start_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">upper_bound</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">new_start_point</span></code></pre></figure>

<h3 id="running-multiple-iterations">Running multiple iterations</h3>

<p>Putting all these together, the overall optimization function might look something like the following code.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">start_points</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">num_iterations</span><span class="p">,</span> <span class="n">stop_limit</span><span class="p">):</span>
  <span class="n">iter_num</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">start_point_index</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">best_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
  <span class="n">best_point</span> <span class="o">=</span> <span class="bp">None</span>
  <span class="k">while</span> <span class="n">iter_num</span> <span class="o">&lt;</span> <span class="n">num_iterations</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">start_point_index</span> <span class="o">&gt;</span> <span class="n">start_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">curr_point</span> <span class="o">=</span> <span class="n">generate_random_point</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">curr_point</span> <span class="o">=</span> <span class="n">start_points</span><span class="p">[</span><span class="n">start_point_index</span><span class="p">,</span> <span class="p">:]</span>
      <span class="n">start_point_index</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="n">best_iter_score</span><span class="p">,</span> <span class="n">best_iter_point</span> <span class="o">=</span> <span class="n">gradient_descent_iteration</span><span class="p">(</span><span class="n">curr_point</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">best_iter_score</span> <span class="o">&lt;</span> <span class="n">best_score</span><span class="p">:</span>
      <span class="n">best_score</span> <span class="o">=</span> <span class="n">best_iter_score</span>
      <span class="n">best_point</span> <span class="o">=</span> <span class="n">best_iter_point</span>
     
    <span class="k">if</span> <span class="n">best_score</span> <span class="o">&lt;</span> <span class="n">stop_limit</span><span class="p">:</span>
      <span class="k">print</span><span class="p">(</span><span class="s">'Early exit criteria met'</span><span class="p">)</span>
      <span class="k">break</span>
  
  <span class="k">print</span><span class="p">(</span><span class="s">'Best point '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">best_point</span><span class="p">))</span>
  <span class="k">print</span><span class="p">(</span><span class="s">'Best score = </span><span class="si">%.2</span><span class="s">f'</span> <span class="o">%</span><span class="p">(</span><span class="n">best_score</span><span class="p">))</span>    </code></pre></figure>

<h3 id="conclusion">Conclusion</h3>

<p>This algorithm might not yield the most optimal solution. But, it yields the best sub-optimal solution under the given time requirements. A word of caution: do not use this method to solve a problem if you can exhaustively search all the parameter sets in a short time. That is not what this is designed for. I will provide a different implementation that will work for that case. In the complete code, I have used a Python class to encapsulate all the parameters and methods.  I will upload the full code to my Github soon. Have fun Integer Programming.</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The Shy Bulb</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>The Shy Bulb</li>
          <li><a href="mailto:macsdev {at} gmail {dot} com">macsdev {at} gmail {dot} com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/MahadevanSrinivasan">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">MahadevanSrinivasan</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/macsdev">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">macsdev</span>
            </a>
          </li>
          
        </ul>
      </div>

    </div>

  </div>
  <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</footer>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61562983-1', 'auto');
  ga('send', 'pageview');

</script>



  </body>

</html>
