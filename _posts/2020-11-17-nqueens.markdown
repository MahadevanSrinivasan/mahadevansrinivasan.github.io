---
layout: "post"
title:  "Nqueens"
date:   2020-11-17 16:44:00
tags: nqueens 8queens
---

These days, I spend a lot of time doing cross-platform development. Meaning, I write a lot of native (C/C++) which then gets compiled for all sorts of platforms (Windows, Linux, Android, iOS with x86, x64, ARM, ARM64 architectures). There are so many little things I have learnt in the past two years at work. I want to document some of those things so it can help others. 

To make it a little interesting, I am going to use the [8-queens problem](https://en.wikipedia.org/wiki/Eight_queens_puzzle) as a starting point. In the future, I may expand it to use something more complicated. 

### 8 queens problem

Crux of the problem is placing 8 Queens on a chess table without any conflicts. Interestingly, there are quite a few combinations. In fact, a total of 92 combinations are possible. As a fun aside, I have written a javascript version of the same algorithm and [an HTML page](http://shybulb.com/nqueens.html) that loops through all the possible solutions. The algorithm to solve it is quite simple. We use [backtracking](https://en.wikipedia.org/wiki/Backtracking). One possible solution is given below in C++. It is quite a rudimentary backtracking algorithm and is self explanatory. Instead of 8 queens, I have made the algorithm generic for N-queens. At the end of the program, I print out the number of solutions possible. 

{% highlight c %}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>

using namespace std;

bool is_pos_valid(vector<string> & board, int row, int col)
{
  int i = 0, j = 0, limit = board.size();

  /* We have only placed queens till row-1, no need to search further */
  for(i = 0; i < row; i++)
  {
    if(board[i][col] == 'Q') return false;
  }
  /* Go above current row, towards the left diagonal */
  for(i = row, j = col; i  >= 0 && j >= 0; i--, j--)
  {
    if(board[i][j] == 'Q') return false;
  }
  /* Go above current row, towards the right diagonal */
  for(i = row, j = col; i >= 0 && j < limit; i--, j++)
  {
    if(board[i][j] == 'Q') return false;
  }

  return true;
}

void nqueens(vector<string> &board, int row, vector<vector<string> > &solutions)
{
  int limit = board.size();
  if(row == limit)
  {
    solutions.push_back(board);
    return;
  }

  for(int i = 0; i < limit; i++)
  {
    if(is_pos_valid(board, row, i))
    {
      board[row].replace(i, 1, "Q");
      nqueens(board, row+1, solutions);
      board[row].replace(i, 1, ".");
    }
  }
}

int main(int argc, char *argv[])
{
  vector<string> board;
  vector<vector<string> > solutions;
  int n = atoi(argv[1]);
  string s(n, '.');
  for(int i = 0; i < n; i++)
  {
    board.push_back(s);
  }
  nqueens(board, 0, solutions);
  cout << "Num solutions = " << solutions.size() << endl;
}

{% endhighlight %}


### What next?

For the frontend code, I have rewritten the code in some basic Javascript. Since it is javascript, anyone can inspect the code. In the next post, I will show how we can reuse our native C++ code and still show the results on the HTML page using Webassembly. With an added side benefit of protecting our source code!