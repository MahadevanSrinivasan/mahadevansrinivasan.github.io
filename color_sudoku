<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Sudoku for Kids!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            background-color: #f0f9ff; /* Light sky blue background */
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: clamp(300px, 90vmin, 500px); /* Responsive width */
            height: clamp(300px, 90vmin, 500px); /* Responsive height */
            border: 3px solid #0c4a6e; /* Darker blue border for the main grid */
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin: 20px auto; /* Center the grid */
        }
        .sudoku-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #7dd3fc; /* Lighter blue cell border (sky-300) */
            font-size: clamp(1rem, 4vmin, 2rem); /* Responsive font size */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            position: relative; 
            box-sizing: border-box; 
        }

        .border-b-thick { border-bottom-width: 3px !important; border-bottom-color: #0c4a6e !important; }
        .border-r-thick { border-right-width: 3px !important; border-right-color: #0c4a6e !important; }

        .sudoku-cell.selected { background-color: #bae6fd; /* sky-200 */ }
        .sudoku-cell.highlight-area { background-color: #e0f2fe; /* sky-100 */ }
        .sudoku-cell.highlight-same-number { background-color: #fed7aa; /* orange-200 */ }
        .sudoku-cell.is-prefilled {
            background-color: #f1f5f9; /* slate-100 */
            cursor: not-allowed;
        }
        .sudoku-cell.is-prefilled.selected { background-color: #bae6fd; }
        .sudoku-cell.is-prefilled.highlight-area { background-color: #e0f2fe; }
        .sudoku-cell.is-prefilled.highlight-same-number { background-color: #fed7aa; }

        .sudoku-cell.is-error {
            background-color: #fecaca !important; /* red-200 */
            color: #dc2626 !important; /* red-600 */
            box-shadow: 0 0 8px 2px rgba(220, 38, 38, 0.5); /* Red glow for error */
        }
        .number-palette button, .action-buttons button { transition: all 0.2s; }
        .number-palette button:hover, .action-buttons button:hover { transform: translateY(-2px); box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
        .number-palette button:active, .action-buttons button:active { transform: translateY(0px); }

        /* Number specific colors */
        .text-num-1 { color: #ef4444; } .text-num-2 { color: #3b82f6; }
        .text-num-3 { color: #22c55e; } .text-num-4 { color: #eab308; }
        .text-num-5 { color: #8b5cf6; } .text-num-6 { color: #ec4899; }
        .text-num-7 { color: #06b6d4; } .text-num-8 { color: #84cc16; }
        .text-num-9 { color: #000000; }

        .btn-disabled { opacity: 0.6; cursor: not-allowed; }

        @keyframes subtleCorrectGlow {
            0% { box-shadow: 0 0 0px 0px rgba(34, 197, 94, 0); }
            50% { box-shadow: 0 0 10px 5px rgba(34, 197, 94, 0.6); }
            100% { box-shadow: 0 0 0px 0px rgba(34, 197, 94, 0); }
        }
        .correct-glow-animation { animation: subtleCorrectGlow 0.7s ease-out; z-index: 10; }

        /* Toggle Switch Styles */
        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #22c55e; } /* Green when toggle is ON (e.g. Toddler Mode ON) */
        input:focus + .slider { box-shadow: 0 0 1px #22c55e; }
        input:checked + .slider:before { transform: translateX(26px); }
        .hidden-button { display: none !important; }

        /* Confetti Styles */
        .confetti-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 1000; }
        .confetti-piece { position: absolute; width: 10px; height: 10px; opacity: 0; animation: fall 3s ease-out forwards; }
        @keyframes fall {
            0% { transform: translateY(-10vh) rotate(0deg) scale(1); opacity: 1; }
            100% { transform: translateY(110vh) rotate(720deg) scale(0.5); opacity: 0; }
        }

        /* Toast Notification Styles */
        #toast-notification {
            transition-property: opacity, transform;
        }
        /* Style for Puzzle Pal toast */
        .toast-puzzle-pal {
            background-color: #3b82f6; /* Blue for Puzzle Pal */
        }
        .toast-correct-move {
            background-color: #22c55e; /* Green for correct move */
        }
    </style>
</head>
<body class="bg-sky-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div id="toast-notification" class="fixed top-0 left-1/2 transform -translate-x-1/2 -translate-y-full text-white py-3 px-6 rounded-b-lg shadow-lg text-lg opacity-0 duration-300 ease-in-out z-50">
        </div>

    <header class="mb-6 text-center">
        <h1 class="text-4xl md:text-5xl font-bold text-sky-700">Color Sudoku Fun!</h1>
    </header>

    <main class="flex flex-col lg:flex-row items-center lg:items-start gap-8">
        <div id="game-board-container">
            <div id="sudoku-grid" class="sudoku-grid"></div>
        </div>

        <div id="controls-area" class="flex flex-col items-center gap-6 mt-6 lg:mt-0">
            <div id="message-area" class="h-10 text-xl font-semibold text-sky-600 text-center">
                Select a cell and a number!
            </div>
            <div id="number-palette" class="grid grid-cols-5 gap-2 p-3 bg-white rounded-lg shadow-md"></div>
            <div class="flex items-center space-x-2 mb-2">
                <span class="text-gray-700 font-medium">Toddler Mode:</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="toddler-mode-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div id="action-buttons" class="grid grid-cols-2 gap-3 w-full max-w-xs">
                <button id="btn-new-game" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-lg shadow">New Game</button>
                <button id="btn-check" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-lg shadow">Check</button>
                <button id="btn-hint" class="bg-yellow-400 hover:bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg text-lg shadow">Hint</button>
                <button id="btn-puzzle-pal" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg text-lg shadow col-span-2">âœ¨ Puzzle Pal Hint</button> 
                <button id="btn-solve" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg text-lg shadow col-span-2">Solve</button>
            </div>
        </div>
    </main>

    <script>
        const N = 9;
        let board = [];
        let solution = [];
        let prefilledCells = [];
        let selectedCell = null;
        let hintCount = 0;
        const MAX_HINTS = 5;
        // isToddlerModeActive: true means simplified UI (helper buttons hidden)
        // This is active when the toggle is CHECKED (green)
        let isToddlerModeActive = true; 
        const MAX_PUZZLE_ATTEMPTS = 20; 

        const gridElement = document.getElementById('sudoku-grid');
        const numberPaletteElement = document.getElementById('number-palette');
        const messageAreaElement = document.getElementById('message-area');
        const btnNewGame = document.getElementById('btn-new-game');
        const btnCheck = document.getElementById('btn-check');
        const btnHint = document.getElementById('btn-hint');
        const btnSolve = document.getElementById('btn-solve');
        const btnPuzzlePal = document.getElementById('btn-puzzle-pal'); 
        const toddlerModeToggle = document.getElementById('toddler-mode-toggle');
        const toastElement = document.getElementById('toast-notification');
        let toastTimeout = null;

        const numberColorClasses = [ null, 'text-num-1', 'text-num-2', 'text-num-3', 'text-num-4', 'text-num-5', 'text-num-6', 'text-num-7', 'text-num-8', 'text-num-9'];
        const motivatingMessages = ["Great job!", "Awesome!", "You got it!", "Nice one!", "Perfect!", "Super!", "Well done!"];

        function initGame() {
            console.log("Initializing game...");
            updateMessage("Generating puzzle...", "info");
            setTimeout(() => {
                generateNewPuzzle();
                renderBoard();
                setupEventListeners();
                updateMessage("Game started! Select a cell.");
                hintCount = 0;
                // Set the toggle's visual state based on the conceptual isToddlerModeActive
                toddlerModeToggle.checked = isToddlerModeActive; 
                toggleHelperButtonVisibility(); 
                
                // Reset disabled states for a new game, then let toggleHelperButtonVisibility manage them
                btnHint.disabled = false; btnHint.classList.remove('btn-disabled');
                btnCheck.disabled = false; btnCheck.classList.remove('btn-disabled');
                btnSolve.disabled = false; btnSolve.classList.remove('btn-disabled');
                btnPuzzlePal.disabled = false; btnPuzzlePal.classList.remove('btn-disabled');
                toggleHelperButtonVisibility(); // Re-apply visibility & disabled state
            }, 50);
        }
        
        function toggleHelperButtonVisibility() {
            // isToddlerModeActive is true if the toggle is CHECKED (green), meaning simple UI
            isToddlerModeActive = toddlerModeToggle.checked; 
            console.log("Toddler Mode Active (simple UI):", isToddlerModeActive);
            const gameWon = checkIfBoardIsSolved();
            const helperButtons = [btnCheck, btnHint, btnSolve, btnPuzzlePal];

            if (isToddlerModeActive) { // If Toddler Mode is ON (toggle is checked/green) -> HIDE helpers
                helperButtons.forEach(btn => btn.classList.add('hidden-button'));
            } else { // If Toddler Mode is OFF (toggle is unchecked/gray) -> SHOW helpers
                helperButtons.forEach(btn => btn.classList.remove('hidden-button'));
                
                // Set disabled states for helper buttons only when they are visible
                btnHint.disabled = hintCount >= MAX_HINTS || gameWon;
                if (btnHint.disabled) btnHint.classList.add('btn-disabled'); else btnHint.classList.remove('btn-disabled');
                
                btnCheck.disabled = gameWon;
                if (btnCheck.disabled) btnCheck.classList.add('btn-disabled'); else btnCheck.classList.remove('btn-disabled');

                btnSolve.disabled = gameWon;
                if (btnSolve.disabled) btnSolve.classList.add('btn-disabled'); else btnSolve.classList.remove('btn-disabled');

                btnPuzzlePal.disabled = gameWon;
                if (btnPuzzlePal.disabled) btnPuzzlePal.classList.add('btn-disabled'); else btnPuzzlePal.classList.remove('btn-disabled');
            }
        }

        function generateNewPuzzle() { /* ... (no change from previous version) ... */ 
            console.log("Attempting to generate new puzzle...");
            let puzzleAttempts = 0; let numSolutions;
            do {
                let tempBoard = Array(N).fill(null).map(() => Array(N).fill(0));
                solveSudoku(tempBoard); solution = tempBoard.map(r => [...r]);
                board = solution.map(r => [...r]); prefilledCells = [];
                let cellsToRemove = 45; let removableCells = [];
                for(let r=0; r<N; r++) for(let c=0; c<N; c++) removableCells.push({r,c});
                shuffleArray(removableCells); let removedCount = 0;
                for (let i = 0; i < removableCells.length && removedCount < cellsToRemove; i++) {
                    const { r, c } = removableCells[i];
                    if (board[r][c] !== 0) {
                        let tempVal = board[r][c]; board[r][c] = 0;
                        if (countSolutions(board, 1) === 0) { board[r][c] = tempVal; } else { removedCount++; }
                    }
                }
                numSolutions = countSolutions(board, 2); puzzleAttempts++;
                console.log(`Attempt ${puzzleAttempts}: ${numSolutions} solution(s) found.`);
            } while (numSolutions !== 1 && puzzleAttempts < MAX_PUZZLE_ATTEMPTS);
            if (numSolutions !== 1) console.warn(`Failed to generate a unique puzzle. Using last attempt.`);
            prefilledCells = [];
            for (let r=0; r<N; r++) for (let c=0; c<N; c++) if (board[r][c] !== 0) prefilledCells.push({row:r,col:c});
            console.log("Puzzle generated.");
        }
        function countSolutions(cb, limit) { /* ... (no change from previous version) ... */ 
            let count = 0;
            function find(b) {
                if (count >= limit) return; const e = findEmptyCell(b);
                if (!e) { count++; return; } const {row,col} = e;
                for (let num=1; num<=N; num++) {
                    if (isValidPlacement(b,num,row,col)) {
                        b[row][col]=num; find(b);
                        if (count>=limit) return; b[row][col]=0;
                    }
                }
            }
            let bc = cb.map(r=>[...r]); find(bc); return count;
        }
        function solveSudoku(cb) { /* ... (no change from previous version) ... */ 
            const eC = findEmptyCell(cb); if (!eC) return true; const {row,col} = eC;
            const nums = shuffleArray([1,2,3,4,5,6,7,8,9]);
            for (let num of nums) {
                if (isValidPlacement(cb,num,row,col)) {
                    cb[row][col]=num; if(solveSudoku(cb)) return true; cb[row][col]=0;
                }
            } return false;
        }
        function findEmptyCell(bS) { /* ... (no change from previous version) ... */ 
            for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(bS[r][c]===0) return {row:r,col:c}; return null;
        }
        function isValidPlacement(bC, num, r, c) { /* ... (no change from previous version) ... */ 
            for(let i=0;i<N;i++) if(bC[r][i]===num && i!==c) return false;
            for(let i=0;i<N;i++) if(bC[i][c]===num && i!==r) return false;
            const sr=r-(r%3),sc=c-(c%3);
            for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(bC[sr+i][sc+j]===num && (sr+i!==r || sc+j!==c)) return false;
            return true;
        }
        function isCurrentlyValidAt(cb, r, c, val) { /* ... (no change from previous version) ... */ 
            if(val===0) return true;
            for(let i=0;i<N;i++) if(i!==c && cb[r][i]===val) return false;
            for(let i=0;i<N;i++) if(i!==r && cb[i][c]===val) return false;
            const sr=r-(r%3),sc=c-(c%3);
            for(let i=0;i<3;i++) for(let j=0;j<3;j++) {
                const R_=sr+i, C_=sc+j;
                if((R_!==r || C_!==c) && cb[R_][C_]===val) return false;
            } return true;
        }
        function shuffleArray(arr) { /* ... (no change from previous version) ... */ 
            for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];} return arr;
        }

        function renderBoard() { /* ... (no change from previous version) ... */ 
            gridElement.innerHTML = ''; clearHighlights();
            for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) {
                const cell = document.createElement('div');
                cell.classList.add('sudoku-cell');
                cell.dataset.row = r; cell.dataset.col = c;
                if (isPrefilled(r,c)) cell.classList.add('is-prefilled'); 
                if ((c + 1) % 3 === 0 && c < N - 1) cell.classList.add('border-r-thick');
                if ((r + 1) % 3 === 0 && r < N - 1) cell.classList.add('border-b-thick');
                const num = board[r][c];
                if (num !== 0) { cell.textContent = num; cell.classList.add(numberColorClasses[num]); }
                cell.addEventListener('click', () => handleCellClick(cell, r, c));
                gridElement.appendChild(cell);
            }
        }
        function isPrefilled(r, c) { return prefilledCells.some(p => p.row === r && p.col === c); }

        function setupEventListeners() { /* ... (no change from previous version) ... */
            numberPaletteElement.innerHTML = ''; 
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.classList.add('w-10','h-10','md:w-12','md:h-12','rounded-md','font-bold','text-xl','md:text-2xl','shadow-sm','border','border-gray-300',numberColorClasses[i],'bg-white','hover:bg-gray-100');
                btn.addEventListener('click', () => handleNumberInput(i));
                numberPaletteElement.appendChild(btn);
            }
            const eraseBtn = document.createElement('button');
            eraseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg>`;
            eraseBtn.title = "Erase";
            eraseBtn.classList.add('w-10','h-10','md:w-12','md:h-12','rounded-md','font-bold','text-xl','shadow-sm','border','border-gray-300','text-gray-600','bg-white','hover:bg-gray-100','flex','items-center','justify-center');
            eraseBtn.addEventListener('click', () => handleNumberInput(0));
            numberPaletteElement.appendChild(eraseBtn);

            btnNewGame.addEventListener('click', initGame);
            btnCheck.addEventListener('click', checkUserSolution);
            btnHint.addEventListener('click', provideHint);
            btnSolve.addEventListener('click', solvePuzzleCompletely);
            btnPuzzlePal.addEventListener('click', getPuzzlePalHint); 
            toddlerModeToggle.addEventListener('change', toggleHelperButtonVisibility);
        }

        function handleCellClick(cellElement, r, c) { /* ... (no change from previous version) ... */ 
            if (selectedCell && selectedCell.element === cellElement) {
                cellElement.classList.remove('selected'); clearHighlights(true); selectedCell = null;
                updateMessage("Cell deselected. Select a cell."); return;
            }
            if (selectedCell && selectedCell.element) selectedCell.element.classList.remove('selected');
            clearHighlights(true); 
            selectedCell = { element: cellElement, row: r, col: c };
            cellElement.classList.add('selected');
            highlightRelatedCells(r, c, board[r][c]);
            updateMessage(`Selected cell (${r+1},${c+1}). Enter a number.`);
        }

        function handleNumberInput(num) { /* ... (no change from previous version) ... */
            if (!selectedCell) { updateMessage("Please select a cell first!", "error"); return; }
            if (isPrefilled(selectedCell.row, selectedCell.col)) { updateMessage("This cell is part of the puzzle!", "info"); return; }

            const { element, row, col } = selectedCell;
            numberColorClasses.forEach(cls => { if (cls) element.classList.remove(cls); });
            element.classList.remove('is-error'); 

            if (num === 0) { 
                board[row][col] = 0; element.textContent = ''; updateMessage(`Cell (${row+1},${col+1}) erased.`);
            } else {
                board[row][col] = num; 
                element.textContent = num; element.classList.add(numberColorClasses[num]);
                if (!isCurrentlyValidAt(board, row, col, num)) {
                    element.classList.add('is-error');
                    updateMessage(`Careful! ${num} creates a conflict.`, "error"); 
                } else {
                    updateMessage("Keep going!", "info"); 
                    if (board[row][col] === solution[row][col]) { 
                        element.classList.add('correct-glow-animation');
                        setTimeout(() => element.classList.remove('correct-glow-animation'), 700);
                        const randomMsg = motivatingMessages[Math.floor(Math.random() * motivatingMessages.length)];
                        showToast(randomMsg, 'correct-move'); 
                    }
                }
            }
            highlightRelatedCells(row, col, board[row][col]); 
            if (checkIfWon()) {
                showCelebrationEffect();
            }
        }
        
        function clearHighlights(keepErrors = false) { /* ... (no change from previous version) ... */
            document.querySelectorAll('.sudoku-cell').forEach(cell => {
                cell.classList.remove('selected', 'highlight-area', 'highlight-same-number');
                if (!keepErrors) cell.classList.remove('is-error');
            });
        }
        function highlightRelatedCells(r, c, num) { /* ... (no change from previous version) ... */ 
            document.querySelectorAll('.sudoku-cell').forEach(cell => {
                if (!cell.classList.contains('selected') && !cell.classList.contains('is-error')) {
                    cell.classList.remove('highlight-area', 'highlight-same-number');
                }
            });
            for (let i=0;i<N;i++) {
                const rc=gridElement.children[r*N+i], cc=gridElement.children[i*N+c];
                if (rc && !rc.classList.contains('selected')) rc.classList.add('highlight-area');
                if (cc && !cc.classList.contains('selected')) cc.classList.add('highlight-area');
            }
            const sr=r-(r%3),sc=c-(c%3);
            for (let ro=0;ro<3;ro++) for (let co=0;co<3;co++) {
                const bc=gridElement.children[(sr+ro)*N+(sc+co)];
                if (bc && !bc.classList.contains('selected')) bc.classList.add('highlight-area');
            }
            if (num!==0) {
                for (let r_=0;r_<N;r_++) for (let c_=0;c_<N;c_++) {
                    if (board[r_][c_]===num) {
                       const snc=gridElement.children[r_*N+c_];
                       if (snc && !snc.classList.contains('selected')) snc.classList.add('highlight-same-number');
                    }
                }
            }
        }
        function updateMessage(msg, type="info") { /* ... (no change from previous version) ... */
            messageAreaElement.textContent = msg; 
            messageAreaElement.classList.remove('text-sky-600', 'text-red-500', 'text-green-500');
            if (type === "error") messageAreaElement.classList.add('text-red-500');
            else if (type === "success") messageAreaElement.classList.add('text-green-500');
            else messageAreaElement.classList.add('text-sky-600');
        }

        function checkUserSolution() { /* ... (no change from previous version) ... */ 
            console.log("Checking solution..."); let errors = 0; let allFilled = true;
            document.querySelectorAll('.sudoku-cell.is-error').forEach(cell => cell.classList.remove('is-error'));
            for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
                const cellElement = gridElement.children[r*N+c];
                if (board[r][c]===0) allFilled = false;
                else if (board[r][c]!==solution[r][c]) {
                    if (!isPrefilled(r,c)) { errors++; cellElement.classList.add('is-error'); }
                }
            }
            if (errors>0) updateMessage(`Found ${errors} mistake${errors>1?'s':''}. Keep trying!`, "error");
            else if (!allFilled) updateMessage("Looking good so far!", "info");
            else { if(checkIfWon()) showCelebrationEffect(); else updateMessage("Solved correctly!", "success");}
        }
        function checkIfBoardIsSolved() { /* ... (no change from previous version) ... */ 
            for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(board[r][c]===0 || board[r][c]!==solution[r][c]) return false; 
            return true;
        }
        function checkIfWon() { /* ... (no change from previous version, includes disabling buttons) ... */ 
            if (!checkIfBoardIsSolved()) return false;
            updateMessage("Wow! You solved it! ðŸŽ‰", "success");
            if(selectedCell && selectedCell.element) selectedCell.element.classList.remove('selected');
            selectedCell = null; 
            btnHint.disabled = true; btnHint.classList.add('btn-disabled');
            btnPuzzlePal.disabled = true; btnPuzzlePal.classList.add('btn-disabled'); 
            // Check current state of toggle to decide if other buttons should be disabled
            if (!toddlerModeToggle.checked) { // If Toddler Mode is OFF (advanced features were visible)
                 btnCheck.disabled = true; btnCheck.classList.add('btn-disabled');
                 btnSolve.disabled = true; btnSolve.classList.add('btn-disabled');
            }
            return true;
        }
        function provideHint() { /* ... (no change from previous version, includes disabling button) ... */ 
            if (hintCount >= MAX_HINTS || checkIfBoardIsSolved()) {
                if(checkIfBoardIsSolved()) updateMessage("Puzzle already solved!", "success");
                else updateMessage(`No more hints available.`, "info");
                btnHint.disabled = true; btnHint.classList.add('btn-disabled'); return;
            }
            let cells = [];
            for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (board[r][c]===0 || (board[r][c]!==solution[r][c] && !isPrefilled(r,c))) cells.push({r,c});
            if (cells.length===0) { updateMessage("Board correct or full!", "success"); return; }
            const {r,c} = cells[Math.floor(Math.random()*cells.length)];
            const num = solution[r][c]; board[r][c] = num;
            const el = gridElement.children[r*N+c]; el.textContent = num;
            numberColorClasses.forEach(cls => { if(cls) el.classList.remove(cls); });
            el.classList.add(numberColorClasses[num]); el.classList.remove('is-error'); 
            if (!isPrefilled(r,c)) { prefilledCells.push({row:r,col:c}); el.classList.add('is-prefilled'); }
            updateMessage(`Hint: Cell (${r+1},${c+1}) is ${num}.`, "info"); hintCount++;
            if (hintCount >= MAX_HINTS) { btnHint.disabled = true; btnHint.classList.add('btn-disabled'); }
            if (selectedCell && selectedCell.row===r && selectedCell.col===c) highlightRelatedCells(r,c,num);
            if (checkIfWon()) showCelebrationEffect();
        }
        function solvePuzzleCompletely() { /* ... (no change from previous version, includes disabling buttons) ... */
            if (checkIfBoardIsSolved()) { updateMessage("Puzzle is already solved!", "success"); return; }
            board = solution.map(r=>[...r]); prefilledCells = []; 
            for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(board[r][c]!==0) prefilledCells.push({row:r,col:c});
            renderBoard(); updateMessage("Puzzle solved! Try a new game.", "success");
            if(selectedCell && selectedCell.element) selectedCell.element.classList.remove('selected');
            selectedCell = null;
            btnHint.disabled = true; btnHint.classList.add('btn-disabled');
            btnPuzzlePal.disabled = true; btnPuzzlePal.classList.add('btn-disabled'); 
            if (!toddlerModeToggle.checked) { // If Toddler Mode is OFF (advanced features were visible)
                 btnCheck.disabled = true; btnCheck.classList.add('btn-disabled');
                 btnSolve.disabled = true; btnSolve.classList.add('btn-disabled');
            }
            showCelebrationEffect();
        }

        // --- Gemini API Integration ---
        async function getPuzzlePalHint() { /* ... (no change from previous version) ... */
            if (checkIfBoardIsSolved()) {
                showToast("The puzzle is already solved!", 'puzzle-pal', 3000);
                return;
            }
            showToast("Puzzle Pal is thinking... ðŸ¤”", 'puzzle-pal', 5000); 
            btnPuzzlePal.disabled = true; 
            const boardString = board.map(row => row.join('')).join(',');
            const prompt = `You are Puzzle Pal, a friendly and encouraging helper for a child playing Sudoku. 
Here is the current Sudoku board (0 means empty):
${boardString}
Please give one short, simple strategic hint to help the child find the next number. 
Do NOT give the exact answer or cell location. Focus on a general strategy. Keep it to one or two sentences.`;
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const result = await response.json();
                if (result.candidates && result.candidates[0]?.content?.parts?.[0]) {
                    const text = result.candidates[0].content.parts[0].text;
                    showToast("Puzzle Pal says: " + text, 'puzzle-pal', 6000); 
                } else {
                    console.error("Gemini API response error:", result);
                    showToast("Puzzle Pal is a bit shy. Try again!", 'puzzle-pal', 3000);
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                showToast("Oops! Puzzle Pal couldn't connect.", 'puzzle-pal', 3000);
            } finally {
                 if (!checkIfBoardIsSolved()) { btnPuzzlePal.disabled = false; }
            }
        }

        // --- Toast Notification & Celebration Effect ---
        function showToast(message, type = 'correct-move', duration = 2000) { /* ... (no change from previous version) ... */
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastElement.style.opacity = '0';
                toastElement.style.transform = 'translateX(-50%) translateY(-100%)';
            }
            toastElement.textContent = message;
            toastElement.className = 'fixed top-0 left-1/2 transform -translate-x-1/2 -translate-y-full text-white py-3 px-6 rounded-b-lg shadow-lg text-lg opacity-0 duration-300 ease-in-out z-50'; 
            if (type === 'puzzle-pal') {
                toastElement.classList.add('toast-puzzle-pal');
            } else { 
                toastElement.classList.add('toast-correct-move');
            }
            void toastElement.offsetWidth; 
            toastElement.style.opacity = '1';
            toastElement.style.transform = 'translateX(-50%) translateY(0)'; 
            toastTimeout = setTimeout(() => {
                toastElement.style.opacity = '0';
                toastElement.style.transform = 'translateX(-50%) translateY(-100%)'; 
            }, duration);
        }

        function showCelebrationEffect() { /* ... (no change from previous version) ... */
            const container = document.createElement('div');
            container.className = 'confetti-container'; document.body.appendChild(container);
            const confColors = ['#ef4444','#3b82f6','#22c55e','#eab308','#8b5cf6','#ec4899','#06b6d4','#84cc16','#fbbf24','#f472b6'];
            for (let i=0; i<100; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.style.left = Math.random()*100+'vw';
                piece.style.backgroundColor = confColors[Math.floor(Math.random()*confColors.length)];
                piece.style.animationDelay = Math.random()*1.5+'s';
                const size = Math.random()*6+8; piece.style.width = size+'px'; piece.style.height = size+'px';
                container.appendChild(piece);
            }
            setTimeout(() => { if (document.body.contains(container)) document.body.removeChild(container); }, 4500);
        }

        // --- Initialize ---
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
